# 递归算法

递归是一种编程技巧，一种解决问题的思维方式；分治算法和动态规划很大程度上是从递归思想演变而来的。

## 递归思想
递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。我们只需要关注如何把原问题划分成符合条件的子问题，而不需要去研究这个子问题是如何被解决的。递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题，而递归是把问题逐级分解，是纵向的拆分。

递归代码的精髓在于调用自己去解决规模更小的子问题，直到到达结束条件。


## 递归分析
我认为递归是可以简化问题的一种手段。当问题可以被分解成相同结构的小问题时，跳出细节，从整体上看问题，进而高效解决问题。

此外递归看起来简洁漂亮，也非常好解释。

但递归并不是所有情况都是高效的，有时因为递归，堆栈会消耗额外空间，而简单的递推不会消耗空间。

## 递归技巧

关键是我们要相信一个函数可以解决一个问题，千万不要试图跳进细节，人很难模拟电脑去分析这些层层递进的问题。

比如我们遍历一棵树，每次处理好本身的node，然后调用递归去处理left和right就好了，不要考虑 left和right的处理细节，因为函数会自动帮我们处理好下一层的问题。

## 一个栗子
给一个二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数，让你编写 pathSum 函数。

求一棵树中有多少条路径的和是目标值，看起来很复杂，但我们用递归来分析一下就没有那么的复杂了。


首先第一部分，我们先定义这个方程：
```
def pathSum(root,target):
    if not root:
        return 0
     
    return count(root,target) + pathSum(root.right,target) + pathSum(root.left,target)

```
上面这个段代码，很明显的递归思想，我们先不用考虑`count`这个方程怎么工作的，我们是不是就是先以`root`为起点查一下有多少符合的路径，然后在加上left和right这两个部分就可以了。

这个时候你要是想问那left和right是怎么工作的呢，你管他怎么工作的呢，我们已经把这个任务交给这个`pathSum`方程了，方程自己就可以处理好了，不要担心这些东西。

下面我们来写`count`这个方程来查出path的数量。

```
def count(root,target):
    if not root:
        return 0
    return (root.val == target) + count(root.left,target-root.val) + count(root.right,target-root.val)
```

我们又一次用递归把这个`count`方程写完了。

分析一下，如果到root这里，发现root的值刚好等于target，我们是不是就可以认为已经存在一条有用的path了。

如果有，记上1，如果没有，记0。

然后还没完，继续搜索啊，还行left和right。 这里注意我们要更新一下target的值，要抛出掉root的值，看后面会不会有符合剩余值的路径，也都要加在一起。

那你又问left和right怎么工作呢？ 管他那，交给递归就好了，结果自然会返回给你。

这样，我们用两次递归的思想就完成了这道题，当然时间复杂度有些高，但是递归还是很好解释，也帮我们写出了漂亮的代码。


## 总结

递归的基本思想是某个函数直接或者间接地调用自身，这样就把原问题的求解转换为许多性质相同但是规模更小的子问题。

不要想细节，把一切问题交给方程去解决。
