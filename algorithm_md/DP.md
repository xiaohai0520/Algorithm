# 动态规划详解

动态规划一直是算法里的一块硬骨头，leetcode上很多的hard难度的题都来自于动态规划，很多时候动态规划都可以用一种莫名其妙的方式就解决了问题。

为了能够更好的掌握动态规划，这篇文章将对动态规划进行一些分析与理解，看看动态规划有没有框架可寻。


## 1.总体概述

**定义**：是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

**场景**：适用于有重叠子问题和最优子结构性质的问题，例如最长递增子序列，最小编辑距离，背包问题等等。

**难点**：转移方程的建立。


## 2. 动态思想
对于动态规划来说，其实是穷举，是的，我们把所有的情况都列出来，然后想找什么都可以在其中找到。

当我们说穷举的时候，我们说的是暴力解。但是动态规划有一个特征就是**重叠子问题**。这个特征可以让动态规划在穷举的过程中减少了很多不必要的计算。

动态规划的另外一个特征是**最优子结构**，只有子结构是最优的，我们才能最终得到原始问题的最优解。

另外动态规划让人感到难的地方就是写出**转移方程**，只有能从一个状态转移到下一个状态，才能顺利的将穷举进行下去。

贯穿起来就是我们用**转移方程**从一个**最优子结构**转移到另外一个**最优子结构**，然后过程中会用到**重叠子问题**来减少计算次数。

## 3.从最简单的开始理解
**斐波那契数列**可能是所有人入门DP的第一个例子。

我们先用暴力解的方法来解决这个问题。

```
def fib(n):
    if n == 1 or n == 2:
        return 1
    return fib(n-1) + fib(n-2)
```
这个递归的效率非常的低，因为我们在递归的过程中会重复的计算很多子问题。时间复杂度是`O(2^n)`，直接原地爆炸。

这时我们发现这里面存在动归的第一个特性，**重叠子问题**，那我们应该怎么解决这个问题呢？

我们可以在递归的过程中加入一个**备忘录**去记录所计算过的子问题，如果又碰到了这个子问题，我们可以直接调取备忘录中的值。

```
def fib(n):
    memo = [None] * (n + 1)
    def helper(n):
        if n == 1 or n == 2:
            return 1
        if not memo[n]:
            return memo[n]
        memo[n] = helper(n-1) + helper(n-2)
        return memo[n]
     return helper(n)
```
**memo**在这里充当了一个备忘录的角色，帮我们记住了计算过的值，当我们再一次遇到这个子问题的时候，直接返回存好的值就可以了。

在使用了备忘录之后，我们的时间复杂度从`O(2^n)`降低到了`O(n)`。

不要着急，在搞明白了备忘录之后，我们就离动态规划不远了。对于备忘录递归来说，我们是在**自顶向下**，对于动态规划来说就是**自底向上**。

什么叫**自顶向下**？就是我们从问题要求得结果开始，例如我们要求fib(20),那我们就去求fib(19)和fib(18),到最底下的时候就是fib(1) 和 fib(2),
然后我们一层一层的返回结果。

什么叫**自底向上**？就是我们从最底下开始，当问题是很小规模的时候，我们可以很轻易的知道答案，fib(1) = fib(2) = 1，然后我们可以去求fib(3) = fib(2) + fib(1),
一直推到我们想要的fib(20),其实这就是动态规划，动态规划一般都舍弃了递归，通过迭代来进行的。

让我们来用**自底向上**的方法来写一下斐波那契数列吧！

```
def fib(n):
    dp = [1] * (n + 1)
    for i in range(3,n+1):
        dp[i] = dp[i-2] + dp[i-1]
    return dp[n]
```
我们仔细看一下，其实这里的`f(n) = f(n-2) + f(n-1)`就是我们一直说的转移方程。

我们来优化一下这个空间复杂度，我们可以观察到，每次需要的不过是`dp[n-2]` 和 `dp[n-1]`的值，那我们可以只保存这两个值就可以得到最后想要的结果了。

```
def fib(n):
    v1 = v2 = 1
    for i in range(3,n+1):
        temp = v1 + v2    
        v1 = v2
        v2 = temp 
    return v2
```

## 4.总结





